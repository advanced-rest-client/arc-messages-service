<!--
@license
Copyright 2017 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">
<link rel="import" href="arc-messages-service-client.html">
<!--
Messages synchronization service for ARC

It gets the list of messages from ARC data store server and saves the list
of newly created messages in local indexed db. Leter calls to the service
will request for list of messages since last sync time.

### Example

```html
<arc-messages-service platform="electron"></arc-messages-service>
<script>
var service = document.querySelector('arc-messages-service');
service.addEventListener('unread-changed', function(e) {
  console.log('Unread messages list changed', e.detail.value);
  service.readMessages(); // Can be replaced with `auto-messages` property
});

service.addEventListener('messages-changed', function(e) {
  console.log('All messages list changed', e.detail.value);
});
</script>
```

@group Logic Elements
@element arc-messages-service
@demo demo/index.html
-->
<dom-module id="arc-messages-service">
  <template>
    <style>
    :host {
      display: none !important;
    }
    </style>
    <iron-ajax url="[[_serviceUrl]]" auto handle-as="json" last-response="{{messagesResponse}}"></iron-ajax>
  </template>
  <script>
  Polymer({
    is: 'arc-messages-service',
    properties: {
      // Name of the platform to serve data from
      platform: String,
      // Messages endpoint URI
      endpointUri: {
        type: String,
        value: 'https://advancedrestclient-1155.appspot.com/info/messages?platform=chrome'
        // value: 'http://localhost:8080/info/messages?platform=electron'
      },
      // List of messages
      messages: {
        type: Array,
        notify: true
      },
      /**
       * List of unread messages
       */
      unread: {
        type: Array,
        notify: true
      },

      // Timestamp of last check opeartion
      lastChecked: {
        type: Number,
        notify: true
      },
      // List of query parameters to use with the request
      _queryParams: Object,
      // Full URL to the messages endpoint with parameters.
      _serviceUrl: {
        type: String,
        computed: '_computeServiceUrl(endpointUri, platform, _queryParams)'
      },
      /**
       * A URL that points to the script to load for the corresponding
       * Worker instance that will be used for minimally-blocking operations
       * on IndexedDB.
       *
       * By default, this will be the path to
       * `app-indexeddb-mirror-worker.js` as resolved by
       * `Polymer.Base.resolveUrl` for the current element being created.
       */
      workerUrl: {
        type: String,
        value: function() {
          return this.resolveUrl('./arc-messages-service-worker.js');
        }
      },
      /**
       * An instance of `ArcMessagesServiceClient`, which is
       * responsible for negotiating transactions with the corresponding
       * Worker spawned from `workerUrl`.
       */
      client: {
        type: Object,
        computed: '__computeClient(workerUrl)',
        observer: '__clientChanged'
      },
      /**
       * Response ferom the ARC messages endpoint.
       */
      messagesResponse: Object,
      // If set it will read list of all mesages from the datastore
      autoMessages: Boolean
    },

    observers: [
      '_lastCheckedChanged(lastChecked)',
      '_messagesResponseReady(messagesResponse.*)'
    ],
    ready: function() {
      if (!this.lastChecked) {
        this._whenChecked();
      }
    },
    /**
     * Computes `_queryParams` based on the value and stores assigned value
     * to the datastore.
     *
     * @param {Number} lastChecked Timestamp of last check time.
     */
    _lastCheckedChanged: function(lastChecked) {
      if (this.__prohibitQuery) {
        this._storeChecked(lastChecked);
        return;
      }
      // Prohibits service URL observer to be called.
      this._queryParams = undefined;
      var urlParams = {};
      if (lastChecked && lastChecked !== 'never') {
        urlParams.since = lastChecked;
        urlParams.until = Date.now();
      }
      this.__prohibitQuery = true;
      this.lastChecked = Date.now();
      this.__prohibitQuery = false;

      this._queryParams = urlParams;
    },
    /**
     * Checkes when the DB was synchronized and sets `lastChecked` property
     * that triggest `iron-ajax` to request a data.
     */
    _whenChecked: function() {
      // TODO: This is debug
      // this.lastChecked = 'never';
      this.client.transaction('get', 'meta', 'updatetime')
      .then(result => {
        if (!result) {
          this.lastChecked = 'never';
        } else {
          this.lastChecked = result;
        }
      });
    },
    /**
     * Computes service URL depending on platform and url parameters
     *
     * @return {String} Full URL to the messages service endpoint.
     */
    _computeServiceUrl: function(endpointUri, platform, params) {
      var url = endpointUri + '?platform=' + platform;
      Object.keys(params).forEach(name => {
        url += '&' + name + '=' + encodeURIComponent(params[name]);
      });
      return url;
    },
    // Stores the information when last time checked for a messages.
    _storeChecked: function(when) {
      return this.client.transaction('set', 'meta', 'updatetime', when);
    },
    // Connectes the web worker client.
    __clientChanged: function(client) {
      return client.connect();
    },
    // Computes value for the client.
    __computeClient: function(workerUrl) {
      /* global ArcMessagesServiceClient */
      return new ArcMessagesServiceClient(workerUrl);
    },
    /**
     * This is called only when the response is ready, not when any of the
     * @param {[type]} messagesResponse [description]
     * @return {[type]} [description]
     */
    _messagesResponseReady: function(record) {
      if (!record || !record.path || !record.base) {
        return;
      }
      if (record.path === 'messagesResponse') {
        return this.sync(record.base);
      }
      return this.updateRecord(record);
    },

    sync: function(incommingMessages) {
      if (!incommingMessages.data || !incommingMessages.data.length) {
        return this.updateUnread();
      }
      return this.client.keys('data')
      .then(keys => this._sync(incommingMessages.data, keys));
    },

    _sync: function(incommingMessages, existingKeys) {
      existingKeys = existingKeys || [];
      var insert = [];
      if (existingKeys.length === 0) {
        insert = incommingMessages;
      } else {
        insert = incommingMessages.filter(message => {
          return existingKeys.indexOf(message.key) === -1;
        });
      }
      if (!insert.length) {
        return this.updateUnread();
      }
      insert.forEach(message => message.read = 0);
      return this.client.transaction('set-all', 'data', insert)
      .then(() => this.updateUnread());
    },
    /**
     * Updates list of unread messages.
     */
    updateUnread: function() {
      return this.client.indexObjects('data', 'read', 0)
      .then(result => {
        this.set('unread', result);
        return result;
      })
      .then(unread => {
        if (this.autoMessages) {
          Polymer.RenderStatus.afterNextRender(this, () => {
            this.readMessages();
          });
        }
        return unread;
      });
    },
    /**
     * Reads list of all messages from the data store.
     * It sets the `messages` property when ready.
     */
    readMessages: function() {
      return this.client.listObjects('data')
      .then(messages => {
        messages.sort(this._messagesSort);
        this.set('messages', messages);
        return messages;
      });
    },
    /**
     * Sort function for the messages.
     */
    _messagesSort: function(a, b) {
      if (a.time > b.time) {
        return -1;
      }
      if (a.time < b.time) {
        return 1;
      }
      return 0;
    }
  });
  </script>
</dom-module>
